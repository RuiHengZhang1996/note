JDK早期时候： synchronized 的实现是重量级（很慢）的： 去找OS申请锁。 导致synchronize太慢了

后来的改进： 锁升级： 原来都是找os，后来有点改进： sync(Object) 先在object头上加个markword 记录这个线程ID，如果第一个线程访问的时候，内部实现的时候是没有加锁的
（偏向锁）

如果有线程争用的话，升级为自旋锁，这个线程要用的话，就在这里（cpu里）自旋while(10)，等待这个锁，旋十次以后，还得不到就再次升级


升级为重量锁-- 去os找资源要一把锁


各种lock基本上都是自旋锁。

适合自旋锁： 加锁代码执行时间比较短，线程数比较少

适合系统锁：加锁代码执行时间长，线程数多 
